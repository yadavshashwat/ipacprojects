// How to install dependencies and run this index.js file:
// npm init
// npm install hkdf
// npm install atob
// npm install btoa
// node index.js


const crypto = require('crypto');
const HKDF = require('hkdf');
const atob = require('atob');
const btoa = require('btoa');
var fs = require('fs');
start();

function start()
{
    // encodedHex is a very small encoded jpeg file downloaded as a .enc file from WhatsApp servers, and converted to an hex string. The decoded image itself shows a 4x4 pixel dark orange gradient. From here we'll try to decode the image.
    var data = fs.readFileSync('hex.txt');
    // var data_hex=data.toString("hex");
    data_hex=data.toString()
    console.log(typeof data_hex)

    var encodedHex = "15a15b57f8fe2cd238089b5d7cf021f3a870e70843b4267294e244d5868e14355810175c1657ff9e0d5b461a60c986a8bac76531566e7c46a986369f902ff695cd667294acb4dd7daf1f71b4f31444d1838c858ce0257f56c90ebf1b7ee9401d99c7f79c162b5a2eed4324b3d106dbfa99a3070c2c9e7a3b1f2e924b184e7c9557adc3a61b427963081b15a6146f13161cdd3d0aeccd58640fd3cd5f0fdfcc4f158ae8bdaf15e5587b5088bc6bec78091ebddae9ffcb651e3099102f9fd57ea9a88efc15547d49a9720c53fe839d11c4536c806c500462f4da53312ddd799c86f698f55d5330f1b8e344b4ba08193a052baf5d4092322a4c739b22dbe40103b286893c3d922c6b0e0dfdcb466ce6ecb3fc9b424eeed8e08ca01ec4f42515ecae6b99a7d69fdcac269c6e914268036bdb1e7623ae219b552a27e88be0eabaa532c0edbb222ecb186e8647";
    var encodedBytes = hexToBytes(data_hex);
    
    
    // console.log("encodedHex: " + encodedHex + " (" + encodedBytes.length + " bytes)");
    
    // STEP 1: obtain mediaKey and decode it from Base64
    // var mediaKeyBase64 = "gd5RDqKHBi846u5UA3I5hMjgy5ygwPw6+4RttFbGP+M=";
    var mediaKeyBase64 = "0GB4wW13I17+ZKWNltcKW53TATuExXvWYa8qe92xy0E="
    var mediaKeyBytes = base64ToBytes(mediaKeyBase64);
    
    // STEP 2: Expand it to 112 bytes using HKDF with "WhatsApp Image Keys" as input key material
    
    var hkdf = new HKDF("sha256", new Uint8Array(32), mediaKeyBytes);
    hkdf.derive("WhatsApp Image Keys", 112, function (mediaKeyExpanded)
    {
        // console.log("mediaKeyExpanded: " + mdigital envelope routines:EVP_DecryptFinal_ex:bad decryptediaKeyExpanded.toString("hex") + " (" + mediaKeyExpanded.length + " bytes)");
        
        // STEP 3: Split mediaKeyExpanded into iv and cipherKey (macKey and refKey are not needed for decoding)

        var iv = mediaKeyExpanded.slice(0, 16);
        var cipherKey = mediaKeyExpanded.slice(16, 48);
        
        // console.log("iv: " + iv.toString("hex") + " (" + iv.length + " bytes)");
        // console.log("cipherKey: " + cipherKey.toString("hex") + " (" + cipherKey.length + " bytes)");
        
        // STEP 4: Download .enc file (already loaded idigital envelope routines:EVP_DecryptFinal_ex:bad decryptn encodedBytes) and discard the last 10 bytes (mac is not needed for decoding)
        
        encodedBytes = encodedBytes.slice(0, -10);
        
        // STEP 5: Validate media data. Skipping because it's not needed for decoding.
        // STEP 6: Decrypt file with AES-CBC using cipherKey and iv, and unpad it.
        // console.log(typeof encodedBytes)
        
        var decipher = crypto.createDecipheriv("aes-256-cbc", cipherKey, iv);
        var decoded_update= decipher.update(encodedBytes,'hex');
         decoded_update=decoded_update.toString("base64")
         console.log(decoded_update.length)
//         // console.log("decodeupdate type"+typeof decoded_update)
         var decoded = decipher.final("base64");
     
        var fs = require('fs');
        var bothData = atob(decoded_update) + atob(decoded); // binary string
var bothData64 = btoa(bothData)

// // string generated by canvas.toDataURL()
// var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0"
//     + "NAAAAKElEQVQ4jWNgYGD4Twzu6FhFFGYYNXDUwGFpIAk2E4dHDRw1cDgaCAASFOffhEIO"
//     + "3gAAAABJRU5ErkJggg==";
img=bothData64;

img='data:image/png;base64,'+bothData64;
// console.log(img);
function decodeBase64Image(dataString) {
    var matches = dataString.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/),
      response = {};
  
    if (matches.length !== 3) {
      return new Error('Invalid input string');
    }
  
    response.type = matches[1];
    response.data = new Buffer(matches[2], 'base64');
  
    return response;
  }
  
  var imageBuffer = decodeBase64Image(img);
  console.log(imageBuffer);
  fs.writeFile('test.png', imageBuffer.data);

    });
    
}



// Utils

  
function hexToBytes(hexStr)
{
    var intArray = [];
    for (var i = 0; i < hexStr.length; i+=2)
    {
        intArray.push(parseInt(hexStr.substr(i, 2), 16));
    }
    return new Uint8Array(intArray);
}

function base64ToBytes(base64Str)
{
    var binaryStr =  atob(base64Str);
    var byteArray = new Uint8Array(binaryStr.length);
    for (var i = 0; i < binaryStr.length; i++)
    {
        byteArray[i] = binaryStr.charCodeAt(i);
    }
    return byteArray;
}
